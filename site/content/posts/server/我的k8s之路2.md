---
title:  我的k8s之路2
date:   2020-08-01 11:08:00 +0800
categories: ["笔记"]
tags: ["k8s"]
draft: true
keywords: ["k8s","kubectl","kubernetes","Pod","Deployments","ReplicaSet"]
description: "这是k8s的第二篇，但是已经时隔一年了。也不知道是k8s变化了，还是我之前的理解不够正确。不过我看了一眼，觉得上一篇写的一些内容，还是比较浅显易懂的，作为入门速览还不错。不过从这一篇开始，要好好抠细节了"
---


> 这是k8s的第二篇，但是已经时隔一年了。也不知道是k8s变化了，还是我之前的理解不够正确。
> 不过我看了一眼，觉得上一篇写的一些内容，还是比较浅显易懂的，作为入门速览还不错。不过从这一篇开始，要好好抠细节了。

## pod细节

修正上一篇文章说的pod推荐内部只包含单个docker用法。因为一个pod内部拥有多个docker，在很多场景下是非常不错的解决方案。

首先要说明一件事情，既然pod允许内部包含多个docker，而pod内的资源是可以互访的。没有手动挂在共享内容，是如何实现的呢？

pod内部就是一个小集群。通过infra-container来进行连接，也称之为sidecar设计模式。这样设计有一些有点。

![sidecar](/images/server/sidecar.png)

1. 单个image的更新，不会让整个pod重启。从而减少了开销。
2. 解决了pod内容器共享资源的问题。pod内的容器读取到的ip，mac地址等网络相关信息，其实都是infra-container的。
3. 方便拓展功能。例如我要加入一个nginx的转发。拿到一个/a的请求，可以在pod内新增一个用来代理的容器。把请求转发到应用容器的/b上。

## ReplicaSet和Deployments

这里一次讲2种kind:`ReplicaSet`,`Deployments`。

ReplicaSet是用来创建pod的，控制pod的数量、使用的pod版本。

Deployments是一个无状态的应用。他是用来控制各个版本的ReplicaSet。

通过上面来匹配呢？label。

![deployment](/images/server/deployment.png)

```bash
# 查看运行的pods
kubectl get pods
# 查看运行的replicasets
kubectl get replicasets
# 查看运行的deployments
kubectl get deployments
```

## 实例操作

```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
    env: test
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  # 默认是10，保留的10个副本
  revisionHistoryLimit: 0
  template:
    metadata:
      labels:
        app: nginx
        env: test
    spec:
      containers:
        - name: nginx
          image: nginx:1.11.3
          resources:
            requests:
              cpu: 100m
              memory: 100Mi
            limits:
              cpu: 100m
              memory: 100Mi
          ports:
            - containerPort: 80

```

说明：
1. 我们创建一个无状态应用。
2. 给这个deployment加了标签`env: test`和`app: nginx`，方便以后在搜索的时候找到它。
3. 创建了一个rs，需要3个pod，rs通过label去和pod匹配。
4. 使用`nginx-1.11.3`的image创建pod。
5. 限制了每个容器的资源消耗
6. 在集群内部暴露pod的80端口

**操作效果**
```bash
# 先观察pods情况
kubectl get pods --watch
# 通过tt.yml文件创建或者更新集群
kubectl apply -f tt.yml
# 查看deployments
kubectl get deployments
# 通过label过滤查询
kubectl.exe get deployments -l env=test



# 改动一次replicas的数量，查看rs状态
kubectl get rs
# 发现有多个replicas版本，默认是10个，说明默认自带回退10个版本的功能
# 默认回退上一个版本，指定参数可回退到指定版本，但是不推荐使用！！！！
# 应该用apply应用声明的方式来进行，因为命令式存在重复操作的可能性。而声明式是修改最终状态！！！！
kubectl rollout undo deployment/nginx-deployment --to-revision=2
```



## service总结

在pod中有说过sidecar设计模式，在nginx方面解决的是的转发请求。而service则是用来对外提供入口，来访问集群内的pod服务。






## 相关信息

[PSKubectlCompletion](https://github.com/mziyabo/PSKubectlCompletion)：提供powershell的自动补全