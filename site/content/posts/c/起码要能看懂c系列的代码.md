---
title:  起码要能看懂c系列的代码
date:   2019-08-29 11:35:00 +0800
categories: ["笔记"]
tags: ["c","c++"]
keywords: ["c","c++"]
draft: true
description: "之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降且概念繁多。和c同级别的，都没有c混得好。c是事实标准"
---

> 之前在一些文章里面就有说过。程序员是绕不过JavaScript的，即使有时候会恶心到人。。
>
> 而很多硬件的嵌入式开发，算法工程师，底层开发人员则真的可以做一辈子，而免疫JavaScript的侵扰。而JavaScript的每一个改动，都多多少少与c/c++有关。
>
> 可以说大神们用c/c++构建了现在数字化的底层逻辑。比c更底层的，晦涩难懂且开发效率低下，甚至人写的代码经常不如c编译器优化后的代码。比c高级的，性能下降概念繁多。和c同级别的，都没有c混得好。事实上c是事实标准。

前言
===

如果你从来没有了解过编程，而想学习c。那么去搜新手教程慢慢上手。

如果你有其他编程的基础。这篇文章能用来让你快速了解c代码。可以在你不得不去看c代码的时候，看懂他的意图。


基本了解
===

类型
---

二进制的c表达，需要用代码实现

```python
# python用0b开头
a = 0b101
```

八进制

```c
// c用0开头
int a = 08
```

```python
# python用0o开头  数字0和字母o
a = 0o516
```

十六进制

```c
// c用0x开头
int a = 0x2A
```

```python
# python用0x开头
a = 0x2A
```

其中int是2个字节。long int是4个字节。

而float是4个字节。double是8个字节。long double是16个字节。注意在计算的时候，可能存在舍入误差。

char一个字符一个字节。

字符串则会比char多出来一个尾部的`\0`字节。

unsigned则代表没有符号位。例如int类型前面都会有一个符号位。没有符号位则会扩大int的可存储范围

附带补充一点知识。
![C_补码](/images/c/C_补码.png)



数组

```c
int a[10];
// 10个长度，空位补0
int b[10]={1,2,3,4,5};
// 自动检测到长度
int b[]={1,2,3,4,5};
```

而字符串就这样表示
```c
// 长度会是4，因为后面还有一个\0
char c[]="C a";
```

说几个常用的字符串函数吧
1. `strcat`合并
2. `strcpy`拷贝
3. `strcmp`比较
4. `strlen`拿到字符串长度

函数部分
---

1. 函数其实没什么好说的。记得除了库函数(自带标准库),都要定义一下。才能用。
2. 全局变量默认在静态存储区。
3. 加了`static`的局部变量也在静态存储区。
4. `register`的变量会放在寄存器，会提高性能。
5. 外部变量用`extern`声明，则可以在代码中使用。

预处理命令
---

1. `#define PI 3.1415`用PI替代代码中的3.1415。`#undef PI`取消。
```c
// 可以带参数。
#define SQ(y) (y)*(y)
/* 但注意扩起来。否则可能结果有误 */
/* 例如sq=SQ(a+1)会变成sq=a+1*a+1 */
```
2. `#include "stdio.h"`引入头文件。一般都用双引号先从当前目录查找。
3. `#ifdef #else #endif`用来判断执行。`#if`则非0则为true。


指针
---

示例代码
```c
// 声明int变量a和int指针*p
int a,*p;
a=10;
// 把a的地址给p
p=&a;
// 现在用*p即可取到a的值
printf('%d',*p);
```

1. 指针如果指向数组，则默认指向数组的第一个元素。可以通过`*(p+1)`取到第二个元素的值。字符串同理。
2. 函数也是占用连续的内存段。则`int (*pf)();`代表指向一个返回值是int的函数。当指针赋值后，通过`(*pmax)(a)`调用。
3. `int *ap(int x,int y)`代表返回指针。



语法 | 说明
--- | ---
int i; | 定义整型变量 i
int *p; | p 为指向整型数据的指针变量
int a[n]; | 定义整型数组 a，它有 n 个元素
int *p[n]; | 定义指针数组 p，它由 n 个指向整型数据的指针元素组成
int (*p)[n]; | p 为指向含 n 个元素的一维数组的指针变量
int f(); | f 为带回整型函数值的函数
int *p(); | p 为带回一个指针的函数，该指针指向整型数据
int (*p)(); | p 为指向函数的指针，该函数返回一个整型值
int **p; | P 是一个指针变量，它指向一个指向整型数据的指针变量


编译
===

简单来说，编译就是使用`gcc`,`make`,`cmake`等工具来进行的。

如果使用vs或者clion这样的工具，需要了解的是工具的使用方法。而下面我要简单说明的是手工编译。

1. 在项目目录下新建build文件夹。
2. 进入build文件夹使用`cmake ..`生成Makefile
3. 运行make命令编译成功，找到输出文件即可。

linux
---
我在centos7上运行`gcc`,`make`,`cmake`都可以正常使用。

mac
---
用brew安装cmake后，也可以跑通。

windows
---
我是用的[scoop](https://scoop.sh/)安装cmake。

然后安装最新的vs。下载`mingw-get`，然后安装`mingw32-make`。
```bash
cmake -G   "MinGW Makefiles" . # .为当前目录, "MinGW Makefiles"为makefile类型，如果编译器为vs的话使用"NMake Makefiles"
```
看到了Makefile后mingw32-make即可。

难点
===

记录一下难以理解的地方。

指针数组和数组指针
---
在看书的时候，了解到main函数可以接受2个参数。而main函数不能被其他函数调用(有一些编译器不管你这么多，也能编译通过。但是制定标准的委员会明确表明了**不行**)。

`int argc`代表单数的个数。包括程序自己本身。

`char *argv[]`代表一个指向字符串的指针数组。

先说一下我之前的**错误想法**吧。

一个指针数组。那么我拿到的就是一个数组。

那么我应该先用`argv[i]`拿到数组中的第i个指针。然后如何取值呢？用`*(argv[i])`取第一个值。可是报错了。

那么我的理解错误在哪呢？下面用`./helloworld a=1`来举例。

### 第一点，c中没有字符串类型。字符串是由字符数组组成，以\0结尾。字符串又有2个声明的方式。

```c
//可以修改指针的地址，但是无法修改原有的值。存储在内存只读段。只要程序在运行，那么就不会释放。
char *a="hehe";
//可以修改。在函数内接收，用完就会释放掉。
char b[]="hehe";
```

c是如何读取字符串的呢？

在c语言中，指向字符和指向字符串的区别只是在于取值，根本就没有指向字符串的指针。从字符串(字符数组)的首地址开始取值，一直到\0结束，那么这个字符串就读完了。

于是根据例子，系统传递给main函数的就是2个字符数组。也就变成了传递1个包含有2个char*类型指针的指针数组即可。取第n个值，就从数组中第n个指针所指向的地址取值到\0即可。

所以`printf("%s",*a)`中。*a取到的值'h'。而printf中指明了要取一个字符串。所以它打印的结果会一直读到\0才会停止。

### 第二点，要彻底了解的是**数组作为参数的传递**。

1. 我的main会得到一个长度为2的数组。如果用户还输入了b=2，c=3呢？我的的程序是无法预测到用户参数的具体个数。所以main函数无法写死数组长度，所以还会有一个`int argc`参数告诉我才行。
2. 数组在传递的时候，传递的只是首地址。用一小段代码来理解一下发生了什么。
```c
void test3(int ac,char av[]){
    printf("%p\n",av);
    for (int i = 0; i < ac; ++i) {
        printf("%c",av[i]);
    }
}

void test4(char a){
    printf("%p\n",&a);
}

void test5(char *qt[]){
    printf("%p\n", qt);
}

int main(int argc, char *argv[]) {
    char p='p';
    printf("%p\n",&p);
    test4(p);

    char pch[] = "pch";
    printf("%p\n", pch);
    test3(strlen(pch), pch);

    char *qq[]={"q","w"};
    char **qq2=qq;
    printf("%p\n", qq);
    test5(qq);

    return 0;
}
// 结果
// 0x7ffee0afc77f
// 0x7ffee0afc75f
// 0x7ffee0afc77b
// 0x7ffee0afc77b
// pch
// 0x7ffee81d0770
// 0x7ffee81d0770
```
**先看test3和test4的结果**。

可以发现2个变量的数据存在不同的内存区域，char类型传递的是`具体值`，也就是给形参a赋值。也即是我在test4中修改a的值，不会影响到p的值。

test3中2个变量的数据为同一内存区域，数组类型传递的是`值的地址`，也就是让av也指向pch所指向的地方，于是相同的地址指向同一个值。当我使用*av修改值，对应的pch值也会变动。

而通过打印，我们会知道。值的地址指向字符串(字符数组)第一个char。可以用*av直接取值。

**C语言规定，数组名代表数组的首地址，也就是第0号元素的地址**。说明我们在声明了pch以后，就可以把数组名pch看成是一个指针。

那么我们在test3函数中，形参也可以写成char *av(你可以验证看)。

**再看test5的结果。发现地址也是一样的**。

同理就可以推断出，传递的是地址，所以qt是指针类型。根据结果，指针数组传递的就是第一个指针所指向值的地址。直接*qt即可取值。

前面在传递数组的时候，数组名代表着一个指针。同样在传递指针数组的时候，数组名就是第一个元素的地址，而第一个元素是指针。所以数组名qt是指针的指针。

那么我们在test5函数中，形参也可以写成char **qt(你可以验证看)。这也是为什么main函数中char *argv[]也可以写的char **argv的原因了！

得到结论：数组在传递的时候，形参char*和char[]等效。char**与char *[]等效。

同时也说明，数组[i]只不过是指针的一个语法糖，相当于*(p+i)。

所以取值如下：

`char **qt`强调自己是指针。取值用`**qt`。同时可以进行qt++这样的指针运算。

`char *qt[]`强调自己是数组。取值用`qt[0]`。同时可以进行qt[n]这样的数组取值方式。

虽然你的形参是`char **qt`也可以用`qt[0]`取值。但是不方便理解，且容易出错。
```c
// 你的第一感觉应该是用**rrr取值。而不是考虑数组不数组的问题，也用不了数组方式。
int r = 1;
int *rr=&r;
int **rrr = &rr;
```

### 第三点，再来说一下我自己理解错误。

由于之前所接触到的语言，基本的逻辑都是面向对象且没有指针。都是值传递，而不是地址传递。

写过一篇go语言的文章，可我没有深入了解过它的指针。经过翻查，发现go在数组传递的时候也是值传递。在go中，指针是为了减少性能开销存在的。而很少见到有人做指针运算。

而c的指针贯穿了整个语言。在进行值传递的时候，形参可以拿到所有信息，因为要进行赋值操作。值传递会让变量名直接取到值。

而地址传递只有一个地址和类型，需要用到取值符*。且在一个指针指向数组的时候*p和p[0]等价。

只有搞清楚传递的过程中是值还是地址，才能正确的分析问题。


总结
===

好久都没有写博客了..也不知道自己在折腾什么..

c/c++还是很重要的。。